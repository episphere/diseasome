import localforage from 'https://cdn.skypack.dev/localforage';
import {storage} from './storage.js'
localforage.config({
    driver: [
        localforage.INDEXEDDB,
        localforage.LOCALSTORAGE,
        localforage.WEBSQL
    ],
    name: 'localforage'
});

let openSnpDbUrls = localforage.createInstance({
    name: "openSnpDbUrls",
    storeName: "userUrls"
})
let userTxts = localforage.createInstance({
    name: "userTxts",
    storeName: "userTxts"
})

let userPhenotypes = localforage.createInstance({
    name: "userPhenotypes",
    storeName: "userPhenotypes"
})

let usersByPhenotype = localforage.createInstance({
    name: "usersByPhenotype",
    storeName: "usersByPhenotype"
})


const get23 = {}
// get all users with genotype data (23andMe, illumina, ancestry etc)
get23.allUsers = async function () { 
    const newLocal = 'usersFull';
    let dt
    dt = await openSnpDbUrls.getItem(newLocal); // check for users in localstorage
    if (dt == null) {
        let url = 'https://corsproxy.io/?https://opensnp.org/users.json'
        let users = (await (await fetch(url)).json())
        let dt2 = users.sort((a, b) => a.id - b.id)
        dt = openSnpDbUrls.setItem('usersFull', dt2)
    }
    return dt
}

get23.getTxts = async function (usersData) {
    console.log("--------------------------")
    console.log("Retreiving OpenSnp users!")
    console.log("getTxts function running, even retreiving from storage is slow.")
    // clearTableUsingKeyLength(table,maxKeys)
    let arr = []
    let urls = (await usersData).map(x => x["genotype.download_url"])

    //remove old txts if table is full
    // let storageList = await table.keys()
    // //console.log("storageList.filter(x => urls.includes(x)",storageList.filter(x => urls.includes(x)))
    storage.clearTableButKeepKeyList(userTxts, urls)

    for (let i = 0; i < urls.length; i++) {
        let parsedUser2 = await userTxts.getItem(urls[i]);
        console.log("processing user #", i)

        if (parsedUser2 == null) {
            console.log("user",i," NOT found in storage")
            let url2 = 'https://corsproxy.io/?' + urls[i]
            const user = (await (await fetch(url2)).text())
            let parsedUser = (await get23.parseTxts(user, usersData[i]))

            // console.log(" getTxts parsedUser",parsedUser)
            arr.push(parsedUser)
            userTxts.setItem(urls[i], parsedUser);
        } else {
            console.log("user",i," found in storage");
            arr.push(parsedUser2)
        }
    }
    return arr
}
//NOTES: document genes, varianat info, filter larger models(feature selection), find genes with more variants (hotspots)
// Amnouiel, S., K. Yalamanchili, S. Sankararaman, and M. S. Jafri. 2024. Evaluating Ovarian Cancer Chemotherapy Response Using Gene Expression Data and Machine Learning BioMedInformatics. 4(2): 1396-1424
// Amnouiel, S. and M. S. Jafri. 2024. High-Accuracy Prediction of Colorectal Cancer Chemotherapy Efficacy Using Machine Learning Applied to Gene Expression Data Frontiers in Physiology. 14: 1272206.

// create 23andme obj and data 
get23.parseTxts = async function (txt, usersData) {
    let obj = {}
    let rows = txt.split(/[\r\n]+/g)
    // obj.txt = txt
    obj.openSnp = await usersData

    let n = rows.filter(r => (r[0] == '#')).length
    if (n==0){
        obj.meta = false
        obj.cols = rows[n].slice(2).split(/\t/)
    }else {
        obj.meta = rows.slice(0, n - 1).join('\r\n')
        obj.cols = rows[n - 1].slice(2).split(/\t/)
    }
    obj.year = rows[0].split(/\r?\n|\r|\n/g)[0].slice(-4)
    obj.qc = rows[0].substring(0, 37) == '# This data file generated by 23andMe'
    obj.dt = rows.slice(n)
    obj.variant_number = obj.dt.length

    obj.dt = obj.dt.map((r, i) => {
        r = r.split('\t')
        r[2] = parseInt(r[2])
        // position in the chr
        r[4] = i
        return r
    })
    return obj
}

// filter users without 23andme data (type = "23andme")
get23.usersByFileType = async function (type, users) {
    let arr = []
    console.log("usersByFileType,users----,",users)
    users.filter(row => row.genotypes.length > 0).map(dt => {

        // keep user with one or more 23andme files
        dt.genotypes.map(i => {
            if (dt.genotypes.length > 0 && i.filetype == type) {
                let innerObj = {};
                innerObj["name"] = dt["name"];
                innerObj["id"] = dt["id"];
                innerObj["trait"] = dt["trait"];
                innerObj["variation"] = dt["variation"];

                innerObj["genotype.id"] = i.id;
                innerObj["genotype.filetype"] = i.filetype;
                innerObj["genotype.download_url"] = i.download_url.replace("http", "https")
                arr.push(innerObj)
            }
        })
    })
    return arr
}

get23.usersInfoOnePhenotype = async function (phenoId){
// get all users with one specific phenotype,along with phenotype info
// get23.userTxtsByPhenotypeId = async function (phenoId,keysLen) {
    //console.log("---------------------------")

    let allUsers = await  get23.allUsers()
    const cors = `https://corsproxy.io/?`
    let onePhenotypeUrl = `https://opensnp.org/phenotypes/json/variations/${phenoId}.json`
    let users = (await (await fetch(cors + onePhenotypeUrl)).json())
    let userIds = users.users.map(x => x.user_id)
    console.log("users",users)
//     // get user info with phenotype data (even those without genotype data)
    const users2 = allUsers.filter(({id}) => userIds.includes(id));
    console.log("users2",users2)

//     let cleanUsers
//     if (userIds2.length < 6) {
//         cleanUsers = await get23.usersByFileType("23andme", userIds2)
//     } else {
//         cleanUsers = (await get23.usersByFileType("23andme", userIds2.slice(6, 19))).slice(0,3)//.slice(4,15))).slice(0,6)
//         //console.log("Warning: user txts for phenotypeID", phenoId, "> 6. First 6 files used.")
//     }
//     // get 23 and me texts from urls using getTxts function
//     let snpTxts = await get23.getTxts(cleanUsers,keysLen,maxKeys)
//     //console.log("User txts for phenotypeID", phenoId, ": ", snpTxts)
//     return snpTxts
// }
//============================================================
// let  phenotypeUrl = `https://opensnp.org/phenotypes/json/variations/${phenoId}.json`
// // ALL USERS WITH ONE PHENOTYPE (T2D)
// let users = await phenotypeUsersTable.getItem(phenotypeUrl); // check for users in localstorage
// if (users == null) {
//     users = (await (await fetch(cors+phenotypeUrl)).json())
//       //.sort((a, b) => b.number_of_users - a.number_of_users)
//          phenotypeUsersTable.setItem(phenotypeUrl, users)
//  }
//  //console.log("users:",users)
// let userIds = users.users.map( x => x.user_id)

// // ALL PHENOTYPES, WITH CORRESPONDING USERS (even those without genotype data)
// var phenotypeUsers = openSnpUsers.filter(({id}) => userIds.includes(id));

// // retreive phenotype information for each user by filetype
// let usersPheno = await Promise.all(filetypes.map(async function (type){
//     let obj = {}
//             // filter users with genotype data, with 1 or more genotype files (ie. 3 23andme files)
//     let filteredUsers2 = await Promise.all(
//                         (await functions.filterUsers(type, phenotypeUsers)).map( async (row,i)  => {
//             console.log(' type, phenotypeUsers',type, phenotypeUsers)
//             console.log(' filterUsers row,i',row,i)
                            

//             let url = `https://opensnp.org/phenotypes/json/${row.id}.json`
//             // console.log("url",url)

//             let phenoData = await singleUserAllPhenotypesTable.getItem(url); // check for users in localstorage////.phenotypes
//             await functions.timeout(3000)

//             if (phenoData == null) {

//                 phenoData = await ( (await fetch(cors+url))).json()
//                 // console.log("phenoData",phenoData)

//                 await functions.timeout(3000)
//                 singleUserAllPhenotypesTable.setItem(url, phenoData)
//             }
//            // //console.log(`getting ids for ${phenoLabel}`,row.id)
//             row["phenotypes"] = await phenoData.phenotypes
//             return row
//     }))
//     //console.log("filteredUsers2:",filteredUsers2)

//     obj[type] = filteredUsers2
//     return obj
// }))
}
   
get23.usersInfoOnePhenotype(50)

// todo: remove pgs database
get23.userTxtsByPhenotypeId = async function (phenoId, keysLen, maxKeys) {
    console.log("userTxtsByPhenotypeId ------------------------------" )

    let allUsers = await get23.allUsers()
    console.log("allUsers",allUsers)
    const cors = `https://corsproxy.io/?`
    let onePhenotypeUrl = `https://opensnp.org/phenotypes/json/variations/${phenoId}.json`

    // get users with selected phenotype
    let users = await usersByPhenotype.getItem(onePhenotypeUrl)
    console.log("users ",users )

    if (users == null){

        users = (await (await fetch(cors + onePhenotypeUrl)).json())
        console.log("users2 = null ",users )
        console.log("onePhenotypeUrl ",onePhenotypeUrl )

        usersByPhenotype.setItem(onePhenotypeUrl,users)
    }
    let usersIds = (users.users.map(x => x.user_id)).sort((a,b) => a-b)

    // get user info
    const users2 = allUsers.filter(({id}) => usersIds.includes(id));
    console.log("users2 ",users2 )

    // add variation inof and remove "n/a"'s
    let combined = users2.map(item => ({ ...item,
        variation: (users.users.filter(f => f.user_id == item.id).map(x => x.variation)).toString(),//&& f.variation != "N/a"&& f.variation != "N/A"&& f.variation.length!= 0
        trait: users.characteristic
      })).filter(x=> x.variation !== "N/a" && x.variation !== "N/A")
      console.log("combined ",combined,combined.map(x=>x.variation!=="N/a") )


    let cleanUsers
    let maxUsers = 5
    if (combined.length < maxUsers) {
        cleanUsers =  get23.usersByFileType("23andme", combined)
    } else {
        cleanUsers = await (get23.usersByFileType("23andme", combined.slice(9, 22)))//.slice(0,maxUsers)
        //console.log("Warning: user txts for phenotypeID", phenoId, "> 7. First 6 files used.")
        console.log("cleanUsers",cleanUsers)
    }
    // get 23 and me texts from urls using getTxts function
    let snpTxts = await get23.getTxts(cleanUsers, keysLen, maxKeys)
    console.log("snpTxts",snpTxts)

    return snpTxts
}
get23.getUserPhenotypes = async function () {
    const allPhenotypesUrl = 'https://opensnp.org/phenotypes.json'
    const allPhenotypes = await userPhenotypes.getItem(allPhenotypesUrl);

    if (allPhenotypes == null) {
        const cors = `https://corsproxy.io/?`
        const allPhenotypes = (await (await fetch(cors + allPhenotypesUrl)).json()).sort((a, b) => b.number_of_users - a.number_of_users)
        userPhenotypes.setItem(allPhenotypesUrl, allPhenotypes);
    }
    // //console.log(allPhenotypes.length," phenotypes found ",allPhenotypes)
    return allPhenotypes
}

get23.getPhenotypeNameFromId = async function (id) {
    //console.log("---------------------------")
    //console.log("running... get23.getPhenotypeNameFromId function")
    const dt = await get23.getUserPhenotypes()
    //console.log("dt",dt)
    const name = dt.filter(x => x.id == id)[0].characteristic
    //console.log("Phenotype id", id, "corresponds to:", name)
    return name
}
get23.getPhenotypeIdFromName = async function (characteristic) {
    //console.log("---------------------------")
    // console.log("running... get23.getPhenotypeNameFromId function")
    const dt = await get23.getUserPhenotypes()
    // console.log("dt",dt)
    const id = dt.filter(x => x.characteristic == characteristic)[0].id
    console.log("Phenotype name", id, "corresponds to:", characteristic)
    return id
}

// const id = 3
const keysLen = 5
const maxKeys = 14
// // const storageSize = 1.3
// const td2Users = await get23.userTxtsByPhenotypeId(id,keysLen)
// const name = await get23.getPhenotypeNameFromId(id)
// const phenotypes = (await get23.getUserPhenotypes()).sort((a, b) => a.id - b.id)
//console.log("phenotypes",phenotypes)
// const userTableSize = await getLocalForageTableSize(userTxts)

export {get23}