// 23andMe ///////////////////////////////////////////////////////////////////////////////////
// get all users urls genotype data (23andMe, illumina, ancestry etc)-------------------------------
const getUsers = async function (length) {
    let arr = []
    let url = 'https://corsproxy.io/?https://opensnp.org/users.json'
    let users = (await (await fetch(url)).json()).sort((a, b) => a.id - b.id).filter(row => row.genotypes.length > 0).map(dt => {

        // keep user urls  with one or more 23andme files
        dt.genotypes.map(i => {
            if (dt.genotypes.length > 0 && i.filetype == "23andme") {
                let innerObj = {};
                innerObj["name"] = dt["name"];
                innerObj["id"] = dt["id"];
                innerObj["genotype.id"] = i.id;
                innerObj["genotype.filetype"] = i.filetype;
                innerObj["genotype.download_url"] = i.download_url.replace("http", "https")
                arr.push(innerObj)

            }
        })
    })
   // get texts and run qc
    let urls23 = arr.map(x => x["genotype.download_url"]).slice(0, length)
    let txts23 = []
    console.log("total users = ", urls23.length)
    for (let i = 0; i < urls23.length; i++) {
        console.log("user: ", urls23[i])
        let url2 = 'https://corsproxy.io/?' + urls23[i]
        let user = (await (await fetch(url2)).text())
        if (user.substring(0, 37) == '# This data file generated by 23andMe') {
            console.log("This is a valid 23andMe file") //, user.substring(0, 37))
            let parsedUser = await parse23(user, urls23[i])
            txts23.push(parsedUser)
        } else {
            console.log("ERROR:This is NOT a valid 23andMe file:", user.substring(0, 37))
        }
    }
    return txts23
}

// let users = await getUsers()
// console.log("users",users)

// create 23andme obj and data --------------------------
async function parse23(txt, url) {
    // normally info is the file name
    let obj = {}
    let rows = txt.split(/[\r\n]+/g)
    obj.txt = txt
    obj.url = url

    let n = rows.filter(r => (r[0] == '#')).length
    obj.meta = rows.slice(0, n - 1).join('\r\n')
    obj.cols = rows[n - 1].slice(2).split(/\t/)
    obj.dt = rows.slice(n)
    obj.dt = obj.dt.map((r, i) => {
        r = r.split('\t')
        r[2] = parseInt(r[2])
        // position in the chr
        r[4] = i
        return r
    })
    return obj
}
// PGS ///////////////////////////////////////////////////////////////////////////////
const getscoreFiles = async function (pgsIds) {
    var scores = []
    let i = 0
    while (i < pgsIds.length) {
        console.log("pgsIds[i]",pgsIds.length,pgsIds[i])
        let url = `https://www.pgscatalog.org/rest/score/${pgsIds[i]}`
        await timeout(150); // pgs has 100 queries per minute limit
        let data =
            await (fetch(url)).then(function (response) {
                return response.json()
            })
            .then(function (response) {
                return response
            }).catch(function (ex) {
                console.log("There has been an error: ", ex)
            })
        scores.push(data)    
        i += 1
    }
    return scores
}

const timeout = (ms) => {
    return new Promise(resolve => setTimeout(resolve, ms));
}
//console.log("pgs",await getscoreFiles(["PGS002130"]))