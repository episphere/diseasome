import { plotly} from "../dependencies.js";
import localforage from 'https://cdn.skypack.dev/localforage';

localforage.config({
    driver: [
        localforage.INDEXEDDB,
        localforage.LOCALSTORAGE,
        localforage.WEBSQL
    ],
    name: 'localforage'
});
let pgs = localforage.createInstance({
    name: "pgs",
    storeName: "scoreFiles",
})
let fetchAll = localforage.createInstance({
    name: "fetchAll",
    storeName: "urls"
})
let openSnpDbUrls = localforage.createInstance({
    name: "openSnpDbUrls",
    storeName: "userUrls"
})
let openSnpDbUsers = localforage.createInstance({
    name: "openSnpDbUsers",
    storeName: "usersTxt"
})
let output = {pgs:[],snp:[]}
// 23andMe ///////////////////////////////////////////////////////////////////////////////////
// get all users with genotype data (23andMe, illumina, ancestry etc)-------------------------------
async function getUsers() { // opensnp user data includes ancestry, familtyTree, and 23and me genotype data
    const newLocal = 'usersFull';
    let dt
    dt = await openSnpDbUrls.getItem(newLocal); // check for users in localstorage
    if (dt == null) {
        let url = 'https://corsproxy.io/?https://opensnp.org/users.json'
        let users = (await (await fetch(url)).json())
        let dt2 = users.sort((a, b) => a.id - b.id)
        dt = openSnpDbUrls.setItem('usersFull', dt2)
    }
    return dt
}

// filter users without 23andme/ancestry data---------------------------------------------------------
async function filterUsers(type, users) {
    //let users = await getUsers()
    let dt
    let arr = []
    dt = await openSnpDbUrls.getItem(type); // check local storage for user data 
    if (dt == null) {
        console.log("null",null)
        users.filter(row => row.genotypes.length > 0).map(dt => {

            // keep user with one or more 23andme files
            dt.genotypes.map(i => {
                if (dt.genotypes.length > 0 && i.filetype == type) {
                    let innerObj = {};
                    innerObj["name"] = dt["name"];
                    innerObj["id"] = dt["id"];
                    innerObj["genotype.id"] = i.id;
                    innerObj["genotype.filetype"] = i.filetype;
                    innerObj["genotype.download_url"] = i.download_url.replace("http", "https")
                    arr.push(innerObj)

                }
            })
        })
        dt = arr //.filter(x=> x.genotypes.length != 0)
        openSnpDbUrls.setItem(type, dt)
    }
    return dt
}


async function get23(urls) {
    let arr23Txts = []
    for (let i = 0; i < urls.length; i++) {
        let user = await openSnpDbUsers.getItem(urls[i]);

        if (user == null) {
            let url2 = 'https://corsproxy.io/?' + urls[i]
            user = (await (await fetch(url2)).text())
            openSnpDbUsers.setItem(urls[i], user);
        }
        if (user.substring(0, 37) == '# This data file generated by 23andMe') {
            //console.log("This is a valid 23andMe file:", user.substring(0, 37))
            let parsedUser = await parse23(user, urls[i])
            arr23Txts.push(parsedUser)
        } else {
            console.log("ERROR:This is NOT a valid 23andMe file:", user.substring(0, 37))
        }
    }
    return arr23Txts
}

// plot opensnp data types --------------
let users = (await getUsers())
let usersFlat = users.flatMap(x=>x.genotypes)
let datatypes = [...new Set(users.flatMap(x=>x.genotypes.flatMap(e=>e.filetype)))]
// console.log("usersFlat",usersFlat)
var obj = {};
var counter = {}

for (var i = 0, len = usersFlat.length; i < len; i++) {
  obj[usersFlat[i]['filetype']] = usersFlat[i];
  counter[usersFlat[i]['filetype']] = (counter[usersFlat[i]['filetype']] || 0) + 1
}
let datatypesCounts = new Array();
for (var key in obj){
    datatypesCounts.push(extend( obj[key], {count:counter[key]}));
}

function extend(a, b){
    for(var key in b)
        if(b.hasOwnProperty(key))
            a[key] = b[key];
    return a;
}
// console.log("datatypes:",datatypesCounts)

// plot openSNP------------------------------------------------------------
let snpDiv = document.getElementById("snp")
var layout = {
    autosize: false,
    height: 300, 
    width: 400,
    title: `OpenSNP datatypes`,
 margin: {l:150},
    xaxis: {
        autorange: false,
        range: [0, 1000],
        type: 'linear'
    },
    yaxis:{
        title: {
            standoff: 10,
            text: "Counts"},
    }
}
var dt = [{
    x: datatypesCounts.map(x => x.count),
    y: datatypesCounts.map(x => x.filetype),
    type: 'bar',
    orientation: 'h',
    marker: {
        color: Array(datatypesCounts.length).fill([
            'blue', "goldenrod", "magenta",
            '#8c564b', //chestnut brown
            '#9467bd', //muted purple
            'red', //raspberry yogurt pink
            'green', //middle gray
        ]).flat().splice(0, datatypesCounts.length)
    }
}]
plotly.newPlot(snpDiv, dt, layout);
// download button for opensnp data---------------------------------
snpDiv.on('plotly_click', async function (data) {
    let snpLabel = data.points[0].label
    console.log("snp type selected:",snpLabel)
    let results = await filterUsers(snpLabel, users)
    output.snp = results
    console.log("output",output)
    let snpUrls = results.map( x => x["genotype.download_url"])
    
        // add download button for pgsIds
        createButton("snp","snpButton", "download snp urls", snpUrls);
})

// top bar plot
// PGS ///////////////////////////////////////////////////////////////////////////////////
const traitFiles = (await fetchAll2('https://www.pgscatalog.org/rest/trait/all')).flatMap(x => x)
const traits = Array.from(new Set(traitFiles.flatMap(x => x["trait_categories"])
    .sort().filter(e => e.length).map(JSON.stringify)), JSON.parse)
traits.map(x => getAllPgsIdsByCategory(x))

// top bar plot of PGS entries by category--------------------------------------------------------------------------------
let allTraitsDt = (await traitsData(traits)).sort(function (a, b) {
    return b.count - a.count
});
let topBarCategoriesDiv = document.getElementById("topBarCategories")
var layout = {
    height: 500,
    width: 600,
    autosize: false,
   // title: `Counts of PGS entries across ${allTraitsDt.length} Categories`,
     margin: {

       b: 200
    },

    yaxis: {
        title: {
            text: 'Category Counts',
          },
              autorange: false,
        range: [0, 300],
        type: 'linear'
    },
}
var dt = [{
    x: allTraitsDt.map(x => x.trait),
    y: allTraitsDt.map(x => x.count),
    type: 'bar',
    //orientation: 'h',
    marker: {
        color: Array(allTraitsDt.length).fill(['orange', 'green', 'red',
            '#1f77b4', //muted blue
            '#ff7f0e', // safety orange
            '#2ca02c', // cooked asparagus green
            '#d62728', //brick red
            'blue', "goldenrod", "magenta",
            '#9467bd', //muted purple
            '#8c564b', //chestnut brown
            '#e377c2', //raspberry yogurt pink
            '#7f7f7f', //middle gray
            'yellow',
            '#bcbd22', //curry yellow-green
            '#17becf' //blue-teal])
        ]).flat().splice(0, allTraitsDt.length)
    }
}]
plotly.newPlot(topBarCategoriesDiv, dt, layout);

// top bar plot of PGS entries by category--------------------------------------------------------------------------------

let topBarTraitsDiv = document.getElementById("topBarTraits")
let traitList = traitFiles.sort((a, b) => b.associated_pgs_ids.length - a.associated_pgs_ids.length)
var layout = {
    autosize: false,
    height: 700,
    width: 12000,
   // title: `Counts of PGS entries across ${traitList.length} Traits`,
    margin: {
       // t: 200,
        b: 400
    },
    yaxis: {
        title: {
            text: 'Trait Counts',
          },
          constraintoward: 'left',

        autorange: false,
        range: [0, 100],
        type: 'linear'
    },
  
}

var dt = [{
    x: traitFiles.map(x => x.label),
    y: traitFiles.map(x => x.associated_pgs_ids.length),
    type: 'bar',
    //orientation: 'h',
    marker: {
        color: Array(traitList.length).fill(['orange', 'green', 'red',
            '#1f77b4', //muted blue
            '#ff7f0e', // safety orange
            '#2ca02c', // cooked asparagus green
            '#d62728', //brick red
            'blue',
            '#9467bd', //muted purple
            '#8c564b', //chestnut brown
            '#e377c2', //raspberry yogurt pink
            '#7f7f7f', //middle gray
            'yellow',
            '#bcbd22', //curry yellow-green
            '#17becf' //blue-teal])
        ]).flat().splice(0, traitList.length)
    }
}]
plotly.newPlot(topBarTraitsDiv, dt, layout);


// bar chart of variant sizes after click-----------------------------------------
topBarCategoriesDiv.on('plotly_click', async function (data) {
    console.log("data.points[0]",data.points[0])
    let category = data.points[0].label
    console.log("Category selected:",category)

    let pgsIds = getAllPgsIdsByCategory(category)
    let scoreFiles = (await getscoreFiles(pgsIds)).sort((a, b) => a.variants_number - b.variants_number)
    let obj = {}
    obj[category] = scoreFiles
    output.pgs.push(obj)
    console.log("output",output)

    var layout = {
        autosize: true,
        height: 400,
        width: 500,
        title: `Variant sizes for ${pgsIds.length} "${category}" entries `,
        margin: {
            l: 390,
            r: 0,
            t: -10,
            b: -10
        },

        xaxis: {
            autorange: false,
            range: [0, 500],
            type: 'linear'
        }
    }
    var data = [{
        x: scoreFiles.map(x => x.variants_number),
        y: scoreFiles.map(x => x.trait_reported.concat(" " + x.id)),
        type: 'bar',
        orientation: 'h',
        marker: {
            color: Array(scoreFiles.length).fill([data.points[0]['marker.color']]).flat().splice(0, scoreFiles.length)
        }
    }];
    plotly.newPlot('secondBarCategories', data, layout)
    createButton("secondBarCategories","button1", "download pgs IDs",scoreFiles);
})

// pie chart of traits -----------------------------------
topBarCategoriesDiv.on('plotly_click', async function (data) {
    const newH = document.getElementById("pieHeader");
    newH.innerHTML = "Select a subcategory to display entries and variant sizes"
    newH.style = "color: rgb(6, 137, 231);"
    let category = data.points[0].label
    let pgsIds = getAllPgsIdsByCategory(category)
    let scoreFiles = (await getscoreFiles(pgsIds)).sort((a, b) => a.variants_number - b.variants_number)

    var obj = {};
    scoreFiles.forEach(function (item) {
        obj[item.trait_reported] ? obj[item.trait_reported]++ : obj[item.trait_reported] = 1;
    });
    var layout = {
        title: `${Object.keys(obj).length} traits found in "${category}" Category`,
        autosize: true,
    }
    var data = [{
        values: Object.values(obj),
        labels: Object.keys(obj),
        type: 'pie',
        textposition: 'inside'
    }];

    plotly.newPlot('pgsPie', data, layout);

    // bar chart of variant size by trait from pie selection------------------------
    document.getElementById("pgsPie").on('plotly_click', async function (data2) {
        let trait = data2.points[0].label
        console.log("Subcategory selected:",trait)
        let res = scoreFiles.filter(x => x.trait_reported === trait).sort((a, b) => a.variants_number - b.variants_number)
        let obj = {}
        obj[trait] = res
        output.pgs.push(obj)
        console.log("output",output)
        var data = [{
            x: res.map(x => x.variants_number),
            y: res.map(x => x.trait_reported.concat(" " + x.id)),
            type: 'bar',
            orientation: 'h',
            marker: {
                color: data2.points[0].color,
            }
        }];
        var layout = {
            autosize: true,
            title: `Variant sizes ${res.length} "${trait}" entries`,
            margin: {
                l: 250
            },
            xaxis: {
                autorange: false,
                range: [0, 500],
                type: 'linear'
            },
        }
        plotly.newPlot('thirdBarCategories', data, layout);

        // add download button for pgsIds
        createButton("thirdBarCategories","button2", "download pgs IDs",res);
    })
})

//bar chart of traits -----------------------------------------
topBarTraitsDiv.on('plotly_click', async function (data) {
    let trait = data.points[0].label
    console.log("Trait selected:",trait)
    let pgsIds = traitFiles.filter(tfile => tfile.label == trait)[0].associated_pgs_ids
    let scoreFiles = (await getscoreFiles(pgsIds)).sort((a, b) => a.variants_number - b.variants_number)
    let obj = {}
    obj[trait] = scoreFiles
    output.pgs.push(obj)
    console.log("output",output)
    var layout = {
        autosize: true,
        title: `Variant sizes for ${pgsIds.length} "${trait}" entries `,
        margin: {
            l: 390
        },
        xaxis: {
            autorange: false,
            range: [0, 500],
            type: 'linear'
        },
    }
    var data = [{
        x: scoreFiles.map(x => x.variants_number),
        y: scoreFiles.map(x => x.trait_reported.concat(" " + x.id)),
        type: 'bar',
        orientation: 'h',
        marker: {
            color: Array(scoreFiles.length).fill([data.points[0]['marker.color']]).flat().splice(0, scoreFiles.length)
        }
    }];
    plotly.newPlot('secondBarTraits', data, layout);
    // add download button for pgsIds
     // add download button for pgsIds
     createButton("secondBarTraits","button3","download pgs IDs", scoreFiles);
  })

// FUNCTIONS------------------------------------------------------------------------
/** Download contents as a file
 * Source: https://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side
 */
function downloadBlob(content, filename, contentType) {
    // Create a blob
    var blob = new Blob([content], {
        type: contentType
    });
    var url = URL.createObjectURL(blob);

    // Create a link to download it
    var pom = document.createElement('a');
    pom.href = url;
    pom.setAttribute('download', filename);
    pom.click();
}

// make download buttons under plots
function createButton(parent,buttonId, buttonTxt, dt) {
    const button = document.createElement("button");
    button.textContent = buttonTxt;
    button.id = buttonId
    document.getElementById(parent).appendChild(button)
    document.getElementById(buttonId).replaceWith(button)

    button.addEventListener("click", function() {
      downloadBlob(dt, 'export.csv', 'text/csv;charset=utf-8;')
  });
}


// get all data from API without limits--------------------------------------------
async function fetchAll2(url, maxPolls = null) {
    var spinner = document.getElementById("spinner");
    spinner.style.display = "block";
    const allResults = []
    const counts = (await (await (fetch(url))).json())
    if (maxPolls == null) maxPolls = Infinity

    // loop throught the pgs catalog API to get all files using "offset"
    for (let i = 0; i < Math.ceil(counts.count / 100); i++) { //4; i++) { //maxPolls; i++) {
        let offset = i * 100
        let queryUrl = `${url}?limit=100&offset=${offset}`

        // get trait files and scoring files from indexDB if the exist
        let cachedData = await fetchAll.getItem(queryUrl);

        // cach url and data 
        if (cachedData !== null) {
            allResults.push(cachedData)
        } else if (cachedData == null) {
            let notCachedData = (await (await fetch(queryUrl)).json()).results
            fetchAll.setItem(queryUrl, notCachedData);
            allResults.push(notCachedData)
        }
        if (allResults.length > 40) {
            break
        }
    }
    spinner.style.display = "none";
    return allResults
}
// remove local storage api requests that didnt go through--------------------
async function removeLocalStorageValues(target, dbName) {
    let i = await dbName.length();
    while (i-- > 0) {
        let key = await dbName.key(i);

        if ((await dbName.getItem(key)).message != undefined) { //.includes(target)) {
            dbName.removeItem(key);
            console.log("removeLocalStorageValues with failed requests (limits)", i)
        }
    }
}
removeLocalStorageValues('request', pgs)

// get pgsids for all 17 traits ------------------------------------------------
async function traitsData(traits) {
    let dt
    if ((await pgs.getItem("traitsData")) === null) {

        dt = traits.map(trait => {
            let traitFilesArr = []
            let pgsIds = []

            traitFiles.map(tfile => {
                if (trait.includes(tfile["trait_categories"][0])) {
                    traitFilesArr.push(tfile)
                }
            })
            if (traitFilesArr.length != 0) {
                pgsIds.push(traitFilesArr.flatMap(x => x.associated_pgs_ids).sort().filter((v, i) => traitFilesArr.flatMap(x => x.associated_pgs_ids).sort().indexOf(v) == i))
            }
            let pgsIds2 = pgsIds.flatMap(x => x)

            let obj = {}
            obj["trait"] = trait
            obj["count"] = pgsIds2.length
            obj["pgsIds"] = pgsIds2
            obj["traitFiles"] = traitFilesArr
            return obj
        })
        pgs.setItem("traitsData", dt)

    } else if (await pgs.getItem("traitsData") != null) {
        dt = await pgs.getItem("traitsData")
    }
    return dt
}
//--------------------------------------
function getAllPgsIdsByCategory(trait) {
    let traitFilesArr = []
    let pgsIds = []
    // get trait files that match selected trait from drop down
    traitFiles.map(tfile => {
        if (trait.includes(tfile["trait_categories"][0])) {
            traitFilesArr.push(tfile)
        }
    })
    if (traitFilesArr.length != 0) {
        pgsIds.push(traitFilesArr.flatMap(x => x.associated_pgs_ids).sort().filter((v, i) => traitFilesArr.flatMap(x => x.associated_pgs_ids).sort().indexOf(v) == i))
    }
    return pgsIds.flatMap(x => x)

}
//--------------------------------------
const timeout = (ms) => {
    return new Promise(resolve => setTimeout(resolve, ms));
}
//------------------------------------
async function getscoreFiles(pgsIds) {
    var scores = []
    let i = 0
    while (i < pgsIds.length) {
        let url = `https://www.pgscatalog.org/rest/score/${pgsIds[i]}`
        let cachedData = await pgs.getItem(url);
        if (cachedData !== null) {
            scores.push(cachedData)
        } else if (cachedData == null) {
            console.log(i, "No cached data found for ", `${pgsIds[i]}`)
            await timeout(150); // pgs has 100 queries per minute limit
            let notCachedData =
                await (fetch(url)).then(function (response) {
                    return response.json()
                })
                .then(function (response) {
                    return response
                }).catch(function (ex) {
                    console.log("There has been an error: ", ex)
                })
            pgs.setItem(url, notCachedData);
            scores.push(notCachedData)
        }
        i += 1
    }
    return scores
}


